package yubiagent

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rsa"
	"crypto/x509"
	"crypto/x509/pkix"
	"fmt"

	"github.com/rs/zerolog/log"
	"github.com/theparanoids/ysshra/attestation/yubiattest"
	"github.com/theparanoids/ysshra/keyid"
	"golang.org/x/crypto/ssh"
)

type keySlot struct {
	code   string            // The code of the key slot, e.g. "9a", "9e"
	public ssh.PublicKey     // The public key stored in the key slot
	attest *x509.Certificate // The attestation certificate of the key slot
	policy keyid.TouchPolicy // The touch policy of the key slot
}

// Slot returns the key slot in the given yubicoAgent.
func Slot(yubicoAgent YubiAgent, code string) (*keySlot, error) {
	attestationCert, err := yubicoAgent.AttestSlot(code)
	if err != nil {
		return nil, err
	}
	// Due to Infineon Technologies' RSA key generation issue, we do not support RSA
	// certificates generated by YubiKeys with firmware between 4.2.6-4.3.4.
	// Ref: https://www.yubico.com/support/security-advisories/ysa-2017-01/
	if attestationCert.PublicKeyAlgorithm == x509.RSA && isAffectedVersion(attestationCert.Extensions) {
		return nil, fmt.Errorf("found RSA certificate generated by YubiKey with firmware 4.2.6-4.3.4")
	}

	publicKey, err := ssh.NewPublicKey(attestationCert.PublicKey)
	if err != nil {
		return nil, err
	}
	if validateSSHPublicKeyAlgo(publicKey) {
		return nil, fmt.Errorf("unsupported certificate type in keySlot: %s", code)
	}

	touchPolicy := getTouchPolicy(attestationCert)

	return &keySlot{
		code:   code,
		public: publicKey,
		attest: attestationCert,
		policy: touchPolicy,
	}, nil
}

func (s *keySlot) PublicKey() ssh.PublicKey {
	return s.public
}

func (s *keySlot) TouchPolicy() keyid.TouchPolicy {
	return s.policy
}

func (s *keySlot) Serial() (string, error) {
	return yubiattest.ModHex(s.attest)
}

func (s *keySlot) SlotCode() string {
	return s.code
}

func (s *keySlot) AttestCert() *x509.Certificate {
	return s.attest
}

// getTouchPolicy returns the touch policy coded in the given attestation certificate
func getTouchPolicy(attestCert *x509.Certificate) keyid.TouchPolicy {
	var touch = keyid.DefaultTouch
	if attestCert == nil {
		return touch
	}
	for _, ext := range attestCert.Extensions {
		// NOTE: The following id is the touch policy stored in attestation certificate.
		//       Refer: https://developers.yubico.com/PIV/Introduction/PIV_attestation.html
		if ext.Id.String() == "1.3.6.1.4.1.41482.3.8" {
			touch = keyid.TouchPolicy(ext.Value[1])
		}
	}
	return touch
}

// YubiKeys with firmaware version 4.2.6 - 4.3.4 are only affected by
// Infineon RSA key generation issue
func isAffectedVersion(extensions []pkix.Extension) bool {
	for _, ext := range extensions {
		if ext.Id.String() == "1.3.6.1.4.1.41482.3.3" {
			version := int(ext.Value[0])*100 + int(ext.Value[1])*10 + int(ext.Value[2])
			if version >= 426 && version <= 434 {
				log.Printf("affected firmware detected, %v", version)
				return true
			}
		}
	}
	return false
}

// validateSSHPublicKeyAlgo validates certs created in 9e and 9a slots.
func validateSSHPublicKeyAlgo(pub crypto.PublicKey) bool {
	switch pk := pub.(type) {
	case *rsa.PublicKey:
		switch pk.Size() * 8 {
		case 2048:
			return true
		default:
			return false
		}
	case *ecdsa.PublicKey:
		switch pk.Curve {
		case elliptic.P256(), elliptic.P384():
			return true
		default:
			return false
		}
	// ed25519 is non-supported key algo for now.
	// case *ed25519.PublicKey:
	// 	return true
	default:
		return false
	}
}
